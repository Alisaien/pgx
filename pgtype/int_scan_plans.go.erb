package pgtype

import (
	"fmt"
	"strconv"
)

<%# Any text to all integer types %>
<% [
  ["8", 8],
  ["16", 16],
  ["32", 32],
  ["64", 64],
  ["", 0]
].each do |type_suffix, bit_size| %>
type scanPlanTextAnyToInt<%= type_suffix %> struct{}

func (scanPlanTextAnyToInt<%= type_suffix %>) Scan(ci *ConnInfo, oid uint32, formatCode int16, src []byte, dst interface{}) error {
	if src == nil {
		return fmt.Errorf("cannot scan null into %T", dst)
	}

	p, ok := (dst).(*int<%= type_suffix %>)
	if !ok {
		return ErrScanTargetTypeChanged
	}

	n, err := strconv.ParseInt(string(src), 10, <%= bit_size %>)
	if err != nil {
		return err
	}

	*p = int<%= type_suffix %>(n)
	return nil
}

type scanPlanTextAnyToUint<%= type_suffix %> struct{}

func (scanPlanTextAnyToUint<%= type_suffix %>) Scan(ci *ConnInfo, oid uint32, formatCode int16, src []byte, dst interface{}) error {
	if src == nil {
		return fmt.Errorf("cannot scan null into %T", dst)
	}

	p, ok := (dst).(*uint<%= type_suffix %>)
	if !ok {
		return ErrScanTargetTypeChanged
	}

	n, err := strconv.ParseUint(string(src), 10, <%= bit_size %>)
	if err != nil {
		return err
	}

	*p = uint<%= type_suffix %>(n)
	return nil
}
<% end %>

<%# PostgreSQL binary integers to fixed size Go integers %>
<% [
  [16, 8],
  [16, 16],
  [16, 32],
  [16, 64],
].each do |src_bit_size, dst_bit_size| %>
<% src_byte_size = src_bit_size / 8 %>
type scanPlanBinaryInt<%= src_byte_size %>ToInt<%= dst_bit_size %> struct{}

func (scanPlanBinaryInt<%= src_byte_size %>ToInt<%= dst_bit_size %>) Scan(ci *ConnInfo, oid uint32, formatCode int16, src []byte, dst interface{}) error {
	if src == nil {
		return fmt.Errorf("cannot scan null into %T", dst)
	}

	if len(src) != <%= src_byte_size %> {
		return fmt.Errorf("invalid length for int<%= src_byte_size %>: %v", len(src))
	}

	p, ok := (dst).(*int<%= dst_bit_size %>)
	if !ok {
		return ErrScanTargetTypeChanged
	}

  <% if dst_bit_size < src_bit_size %>
	n := int<%= src_bit_size %>(binary.BigEndian.Uint<%= src_bit_size %>(src))
	if n < math.MinInt<%= dst_bit_size %> {
		return fmt.Errorf("%d is less than minimum value for int<%= dst_bit_size %>", n)
	} else if n > math.MaxInt<%= dst_bit_size %> {
		return fmt.Errorf("%d is greater than maximum value for int<%= dst_bit_size %>", n)
	}

	*p = int<%= dst_bit_size %>(n)
  <% else %>
	*p = int<%= dst_bit_size %>(binary.BigEndian.Uint<%= src_bit_size %>(src))
  <% end %>

	return nil
}

type scanPlanBinaryInt<%= src_byte_size %>ToUint<%= dst_bit_size %> struct{}

func (scanPlanBinaryInt<%= src_byte_size %>ToUint<%= dst_bit_size %>) Scan(ci *ConnInfo, oid uint32, formatCode int16, src []byte, dst interface{}) error {
	if src == nil {
		return fmt.Errorf("cannot scan null into %T", dst)
	}

	if len(src) != <%= src_byte_size %> {
		return fmt.Errorf("invalid length for uint<%= src_byte_size %>: %v", len(src))
	}

	p, ok := (dst).(*uint<%= dst_bit_size %>)
	if !ok {
		return ErrScanTargetTypeChanged
	}

	n := int<%= src_bit_size %>(binary.BigEndian.Uint<%= src_bit_size %>(src))
	if n < 0 {
		return fmt.Errorf("%d is less than minimum value for uint<%= dst_bit_size %>", n)
	}
  <% if dst_bit_size < src_bit_size %>
	if n > math.MaxUint<%= dst_bit_size %> {
		return fmt.Errorf("%d is greater than maximum value for uint<%= dst_bit_size %>", n)
	}
  <% end %>
	*p = uint<%= dst_bit_size %>(n)

	return nil
}
<% end %>

<%# PostgreSQL binary integers to Go machine integers %>
<% [16].each do |src_bit_size| %>
<% src_byte_size = src_bit_size / 8 %>
type scanPlanBinaryInt<%= src_byte_size %>ToInt struct{}

func (scanPlanBinaryInt<%= src_byte_size %>ToInt) Scan(ci *ConnInfo, oid uint32, formatCode int16, src []byte, dst interface{}) error {
	if src == nil {
		return fmt.Errorf("cannot scan null into %T", dst)
	}

	if len(src) != <%= src_byte_size %> {
		return fmt.Errorf("invalid length for int<%= src_byte_size %>: %v", len(src))
	}

	p, ok := (dst).(*int)
	if !ok {
		return ErrScanTargetTypeChanged
	}

  <% if 32 < src_bit_size %>
	n := int64(binary.BigEndian.Uint<%= src_bit_size %>(src))
	if n < math.MinInt {
		return fmt.Errorf("%d is less than minimum value for int", n)
	} else if n > math.MaxInt {
		return fmt.Errorf("%d is greater than maximum value for int", n)
	}

	*p = int(n)
  <% else %>
	*p = int(binary.BigEndian.Uint<%= src_bit_size %>(src))
  <% end %>

	return nil
}

type scanPlanBinaryInt<%= src_byte_size %>ToUint struct{}

func (scanPlanBinaryInt<%= src_byte_size %>ToUint) Scan(ci *ConnInfo, oid uint32, formatCode int16, src []byte, dst interface{}) error {
	if src == nil {
		return fmt.Errorf("cannot scan null into %T", dst)
	}

	if len(src) != <%= src_byte_size %> {
		return fmt.Errorf("invalid length for uint<%= src_byte_size %>: %v", len(src))
	}

	p, ok := (dst).(*uint)
	if !ok {
		return ErrScanTargetTypeChanged
	}

	n := int64(binary.BigEndian.Uint<%= src_bit_size %>(src))
	if n < 0 {
		return fmt.Errorf("%d is less than minimum value for uint", n)
	}
  <% if 32 < src_bit_size %>
	if uint64(n) > math.MaxUint {
		return fmt.Errorf("%d is greater than maximum value for uint", n)
	}
  <% end %>
	*p = uint(n)

	return nil
}
<% end %>

<%# PostgreSQL binary integers to Go Int64Scanner %>
<% [16].each do |src_bit_size| %>
<% src_byte_size = src_bit_size / 8 %>
type scanPlanBinaryInt<%= src_byte_size %>ToInt64Scanner struct{}

func (scanPlanBinaryInt<%= src_byte_size %>ToInt64Scanner) Scan(ci *ConnInfo, oid uint32, formatCode int16, src []byte, dst interface{}) error {
	s, ok := (dst).(Int64Scanner)
	if !ok {
		return ErrScanTargetTypeChanged
	}

	if src == nil {
    return s.ScanInt64(0, false)
	}

	if len(src) != <%= src_byte_size %> {
		return fmt.Errorf("invalid length for int<%= src_byte_size %>: %v", len(src))
	}


	n := int64(binary.BigEndian.Uint<%= src_bit_size %>(src))

  return s.ScanInt64(n, true)
}
<% end %>

type scanPlanTextAnyToInt64Scanner struct{}

func (scanPlanTextAnyToInt64Scanner) Scan(ci *ConnInfo, oid uint32, formatCode int16, src []byte, dst interface{}) error {
	s, ok := (dst).(Int64Scanner)
	if !ok {
		return ErrScanTargetTypeChanged
	}

	if src == nil {
    return s.ScanInt64(0, false)
	}

	n, err := strconv.ParseInt(string(src), 10, 64)
	if err != nil {
		return err
	}

  err = s.ScanInt64(n, true)
	if err != nil {
		return err
	}

	return nil
}
